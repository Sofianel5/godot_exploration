[gd_scene load_steps=5 format=3 uid="uid://bh8yn4qxd8w7h"]

[sub_resource type="GDScript" id="GDScript_1"]
script/source = "extends CharacterBody3D

@export var health = 100
@export var max_health = 100
@export var speed = 3.0
@export var attack_damage = 20
@export var detection_range = 15.0
@export var attack_range = 2.0

@onready var nav_agent = $NavigationAgent3D

var player_ref: Node3D
var attack_timer = 0.0

enum EnemyState {
	IDLE,
	CHASING,
	ATTACKING,
	DEAD
}

var current_state = EnemyState.IDLE

func _ready():
	var players = get_tree().get_nodes_in_group(\"player\")
	if players.size() > 0:
		player_ref = players[0]
	
	add_to_group(\"enemies\")
	velocity = Vector3.ZERO

func _physics_process(delta):
	if current_state == EnemyState.DEAD:
		return
	
	update_ai(delta)
	
	# Apply gravity
	if not is_on_floor():
		velocity.y -= get_gravity().y * delta
	
	# Move towards target if chasing
	if current_state == EnemyState.CHASING:
		if player_ref:
			var direction = (player_ref.global_position - global_position).normalized()
			velocity.x = direction.x * speed
			velocity.z = direction.z * speed
			
			# Look at target
			look_at(player_ref.global_position, Vector3.UP)
	else:
		# Apply friction when not moving
		velocity.x *= 0.8
		velocity.z *= 0.8
	
	move_and_slide()

func update_ai(delta):
	if not player_ref:
		return
	
	var distance_to_player = global_position.distance_to(player_ref.global_position)
	
	match current_state:
		EnemyState.IDLE:
			if distance_to_player <= detection_range:
				current_state = EnemyState.CHASING
		
		EnemyState.CHASING:
			if distance_to_player > detection_range * 1.2:
				current_state = EnemyState.IDLE
			elif distance_to_player <= attack_range:
				current_state = EnemyState.ATTACKING
				attack_timer = 1.0
		
		EnemyState.ATTACKING:
			attack_timer -= delta
			if attack_timer <= 0.0:
				perform_attack()
				if distance_to_player > attack_range:
					current_state = EnemyState.CHASING
				else:
					attack_timer = 1.0

func perform_attack():
	if player_ref and player_ref.has_method(\"take_damage\"):
		player_ref.take_damage(attack_damage)
		print(\"Enemy attacks for \", attack_damage, \" damage!\")

func take_damage(damage: int):
	if current_state == EnemyState.DEAD:
		return
	
	health -= damage
	print(\"Enemy took \", damage, \" damage! Health: \", health, \"/\", max_health)
	
	# Hit animation - flash white briefly
	play_hit_animation()
	
	if health <= 0:
		die()
	else:
		current_state = EnemyState.CHASING

func play_hit_animation():
	var mesh_instance = $MeshInstance3D
	var original_material = mesh_instance.material_override
	
	# Flash white
	var white_material = StandardMaterial3D.new()
	white_material.albedo_color = Color.WHITE
	mesh_instance.material_override = white_material
	
	# Return to red after 0.1 seconds
	var timer = Timer.new()
	add_child(timer)
	timer.wait_time = 0.1
	timer.one_shot = true
	timer.timeout.connect(func(): 
		mesh_instance.material_override = original_material
		timer.queue_free()
	)
	timer.start()

func die():
	current_state = EnemyState.DEAD
	health = 0
	
	# Disable collision
	collision_layer = 0
	collision_mask = 0
	
	print(\"Enemy died!\")
	
	# Emit signal before dying
	var main_scene = get_tree().current_scene
	if main_scene.has_method(\"on_enemy_died\"):
		main_scene.on_enemy_died()
	
	# Start death animation
	start_death_animation()

func start_death_animation():
	var mesh_instance = $MeshInstance3D
	
	# Create shrinking/fading animation using tween
	var tween = create_tween()
	tween.set_parallel(true)  # Allow multiple animations at once
	
	# Shrink the enemy over 2 seconds
	tween.tween_method(
		func(scale_value): mesh_instance.scale = Vector3.ONE * scale_value,
		1.0, 0.0, 2.0
	)
	
	# Create a material that fades out
	var death_material = StandardMaterial3D.new()
	death_material.albedo_color = Color(0.3, 0.3, 0.3, 1.0)  # Dark gray
	death_material.transparency = BaseMaterial3D.TRANSPARENCY_ALPHA
	
	mesh_instance.material_override = death_material
	
	# Fade out the material
	tween.tween_method(
		func(alpha): death_material.albedo_color.a = alpha,
		1.0, 0.0, 2.0
	)
	
	# Rotate while dying for dramatic effect
	tween.tween_method(
		func(rotation): mesh_instance.rotation.y = rotation,
		0.0, PI * 4, 2.0  # 2 full rotations
	)
	
	# Remove after animation completes using finished signal
	tween.finished.connect(queue_free)

func get_health() -> int:
	return health

func get_max_health() -> int:
	return max_health
"

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_1"]

[sub_resource type="StandardMaterial3D" id="StandardMaterial3D_1"]
albedo_color = Color(1, 0.2, 0.2, 1)

[sub_resource type="CapsuleMesh" id="CapsuleMesh_1"]

[node name="Enemy" type="CharacterBody3D" groups=["enemies"]]
collision_layer = 4
collision_mask = 2
script = SubResource("GDScript_1")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
shape = SubResource("CapsuleShape3D_1")

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
material_override = SubResource("StandardMaterial3D_1")
mesh = SubResource("CapsuleMesh_1")

[node name="NavigationAgent3D" type="NavigationAgent3D" parent="."]
